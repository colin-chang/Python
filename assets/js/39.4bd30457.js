(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{390:function(t,s,a){"use strict";a.r(s);var e=a(25),n=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"垃圾回收（gc）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收（gc）"}},[t._v("#")]),t._v(" 垃圾回收（GC）")]),t._v(" "),a("p",[a("strong",[t._v("Python中的垃圾回收(GC)是以引用计数为主，分代回收为辅")]),t._v("。两种GC方式与C#类似，不同的是，Python的引用计数GC适时进行，C#则按策略不定时执行。")]),t._v(" "),a("p",[t._v("GC的工作除了垃圾回收，还负责对新对象分配内存。")]),t._v(" "),a("h2",{attrs:{id:"_1-引用计数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-引用计数"}},[t._v("#")]),t._v(" 1. 引用计数")]),t._v(" "),a("p",[t._v("Python里每一个东西都是对象，它们的核心就是一个结构体"),a("code",[t._v("PyObject")]),t._v("(CPython)。")]),t._v(" "),a("div",{staticClass:"language-c line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typedef")]),t._v(" struct_object "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" ob_refcnt"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    struct_typeobject "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("ob_type"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" PyObject"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br")])]),a("p",[t._v("其中"),a("code",[t._v("ob_refcnt")]),t._v("就是作引用计数。当对象有新的引用时，它的"),a("code",[t._v("ob_refcnt")]),t._v("就会增加，当引用它的对象被删除，它的"),a("code",[t._v("ob_refcnt")]),t._v("就会减少。当引用计数为0时，该对象就会被GC。")]),t._v(" "),a("p",[a("code",[t._v("sys")]),t._v("模块的"),a("code",[t._v("sys.getrefcount(obj)")]),t._v("可以获取对象的引用计数，由于该函数执行时会内部会定义变量接收对象，统计完即释放，所以"),a("code",[t._v("测量引用数=实际引用数+1")]),t._v("。")]),t._v(" "),a("div",{staticClass:"language-py line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-py"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" sys\n\na "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\nb "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" a\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("print")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("sys"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("getrefcount"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 3")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br")])]),a("p",[t._v("以下行为引用计数+1：")]),t._v(" "),a("ul",[a("li",[t._v("对象被创建，例如a=23")]),t._v(" "),a("li",[t._v("对象被引用，例如b=a")]),t._v(" "),a("li",[t._v("对象被作为参数，传入到一个函数中，例如func(a)")]),t._v(" "),a("li",[t._v("对象作为一个元素，存储在容器中，例如list1=[a,a]")])]),t._v(" "),a("p",[t._v("以下行为引用计数-1:")]),t._v(" "),a("ul",[a("li",[t._v("对象的别名被显式销毁，例如del a")]),t._v(" "),a("li",[t._v("对象的别名被赋予新的对象，例如a=24")]),t._v(" "),a("li",[t._v("一个对象离开它的作用域，例如f函数执行完毕时，func函数中的局部变量（全局变量不会）")]),t._v(" "),a("li",[t._v("对象所在的容器被销毁，或从容器中删除对象")])]),t._v(" "),a("h4",{attrs:{id:"优点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[t._v("#")]),t._v(" 优点")]),t._v(" "),a("ul",[a("li",[t._v("机制简单高效。")]),t._v(" "),a("li",[t._v("实时性强。一旦没有引用，内存立即释放了。")])]),t._v(" "),a("h4",{attrs:{id:"缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[t._v("#")]),t._v(" 缺点")]),t._v(" "),a("ul",[a("li",[t._v("维护引用计数消耗资源。")]),t._v(" "),a("li",[t._v("无法解决循环引用问题。")])]),t._v(" "),a("div",{staticClass:"language-py line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-py"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 循环引用示例")]),t._v("\nlist1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" list2 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\nlist1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("append"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("list2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\nlist2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("append"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("list1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("del")]),t._v(" list1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" list2\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br")])]),a("p",[a("img",{attrs:{src:"https://i.loli.net/2020/02/25/pHAMCJiozctRYXG.jpg",alt:"循环引用"}})]),t._v(" "),a("ul",[a("li",[a("p",[a("code",[t._v("list1=[]")]),t._v("会首先申请一块内存假设地址为"),a("code",[t._v("addr1")]),t._v(",然后将"),a("code",[t._v("list1")]),t._v("指向"),a("code",[t._v("addr1")]),t._v("。同理假定"),a("code",[t._v("list2")]),t._v("指向"),a("code",[t._v("addr2")]),t._v("。")])]),t._v(" "),a("li",[a("p",[a("code",[t._v("list1.append(list2)")]),t._v("会在"),a("code",[t._v("list1")]),t._v("内创建创建一个对象假定地址为"),a("code",[t._v("addr3")]),t._v("并指向"),a("code",[t._v("list2")]),t._v("地址即"),a("code",[t._v("addr2")]),t._v("。同理假定"),a("code",[t._v("list2")]),t._v("内创建对象地址"),a("code",[t._v("addr4")]),t._v("指向"),a("code",[t._v("addr1")]),t._v("。此时"),a("code",[t._v("addr1")]),t._v("和"),a("code",[t._v("addr2")]),t._v("同时都有两个引用。")])]),t._v(" "),a("li",[a("p",[a("code",[t._v("del list1")]),t._v("会删除"),a("code",[t._v("list1")]),t._v("对"),a("code",[t._v("addr1")]),t._v("的引用，同理"),a("code",[t._v("list2")]),t._v("对"),a("code",[t._v("addr2")]),t._v("的引用也会被删除。此时"),a("code",[t._v("addr1")]),t._v("与"),a("code",[t._v("add2")]),t._v("的引用计数都为1，所占用的内存永远无法被回收,随着出现此问题的变量累积最终将会导致内存泄露。")])])]),t._v(" "),a("h2",{attrs:{id:"_2-分代回收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-分代回收"}},[t._v("#")]),t._v(" 2. 分代回收")]),t._v(" "),a("p",[t._v("为了解决循环引用的问题，Python中辅助使用分代回收(Generational GC)机制，其与C#中GC的分代回收类似。")]),t._v(" "),a("p",[t._v("Python使用一种链表来持续追踪活跃的对象,Python的内部C代码将其称为零代(Generation Zero)。每次创建一个对象时Python会将其加入零代链表。")]),t._v(" "),a("p",[t._v("图中蓝色的箭头表示对象正在被零代链表之外的变量所引用。可以看到ABC和DEF节点包含的引用数为1且没有零代链之外的对象引用，说明它们在零代链表中现存对象中存在引用。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://i.loli.net/2020/02/25/3RxkMWyahKwfNoS.jpg",alt:"generation zero"}})]),t._v(" "),a("p",[t._v("随后，Python会循环遍历零代链表上的每个对象，检查链表中每个互相引用的对象。在这个过程中，Python会一个接一个的统计内部引用的数量以防过早地释放对象。")]),t._v(" "),a("p",[t._v("根据规则Python会尝试把循环引用的变量引用数减1，在下图中国可以看到ABC和DEF的引用计数已经变归零。这意味着收集器可以释放它们并回收内存空间了。剩下的活跃的对象则被移动到一个新的链表，一代链表。\n"),a("img",{attrs:{src:"https://i.loli.net/2020/02/25/vQmApine1R7rXaF.jpg",alt:"generation one"}})]),t._v(" "),a("p",[t._v("零代链表的GC过程同样发生在一代链表中，经过一代链表GC后，剩下活跃的对象会被移动二代链表。代码长期使用的对象和持续访问的活跃对象，会从零代链表转移到一代再转移到二代。通过不同的阈值设置，Python可以在不同的时间间隔处理这些对象。Python处理零代最为频繁，其次是一代然后才是二代。回收高"),a("code",[t._v("higher generation")]),t._v("时也会清理"),a("code",[t._v("lower generation")]),t._v(",如回收二代时会回收一代和零代。")]),t._v(" "),a("h2",{attrs:{id:"_3-gc-模块"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-gc-模块"}},[t._v("#")]),t._v(" 3. gc 模块")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"left"}},[t._v("模块成员")]),t._v(" "),a("th",{staticStyle:{"text-align":"left"}},[t._v("功能说明")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("collect([generation])")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("显式进行垃圾回收。返回不可达(unreachable objects)对象的数目")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("garbage")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("垃圾回收后的对象会放在此列表里中")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("get_threshold()")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("获取的gc模块中自动执行垃圾回收的频率")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("set_threshold(threshold0[, threshold1[, threshold2])")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("设置自动执行垃圾回收的频率")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("get_count()")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("获取当前自动执行垃圾回收的计数器，返回一个长度为三个值组成的元组")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("set_debug(flags)")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("设置gc的debug日志，一般设置为"),a("code",[t._v("gc.DEBUG_LEAK")])])])])]),t._v(" "),a("p",[t._v("如果gc.get_count()返回(262, 3, 19)。其中262是指距离上次零代垃圾检查，Python分配内存的数目减去释放内存的数目。相当于上次GC后内存消耗。3是指距离上次一代垃圾检查，零代垃圾检查的次数，同理，19是指距离上一次二代垃圾检查，一代垃圾检查的次数。")]),t._v(" "),a("p",[t._v("gc模快有一个自动垃圾回收的阀值，即通过"),a("code",[t._v("gc.get_threshold")]),t._v("函数获取到的长度为3的元组，例如(700,10,10)每一次计数器的增加，gc模块就会检查增加后的计数是否达到阀值的数目，如果是，就会执行对应的代数的垃圾检查，然后重置计数器。例如，假设阀值是(700,10,10)：")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("当计数器从(699,3,0)增加到(700,3,0)，gc模块就会执行gc.collect(0),即检查零代对象的垃圾，并重置计数器为(0,4,0)\n当计数器从(699,9,0)增加到(700,9,0)，gc模块就会执行gc.collect(1),即检查零、一代对象的垃圾，并重置计数器为(0,0,1)\n当计数器从(699,9,9)增加到(700,9,9)，gc模块就会执行gc.collect(2),即检查零、一、二代对象的垃圾，并重置计数器为(0,0,0)\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br")])]),a("p",[t._v("以下三种情况会触发GC：")]),t._v(" "),a("ul",[a("li",[t._v("调用gc.collect()")]),t._v(" "),a("li",[t._v("当gc模块的计数器达到阀值时")]),t._v(" "),a("li",[t._v("程序退出时")])]),t._v(" "),a("p",[t._v("gc模块唯一处理不了的是循环引用的类都有"),a("code",[t._v("__del__")]),t._v("方法，所以项目中要尽量避免定义"),a("code",[t._v("__del__")]),t._v("方法。")])])}),[],!1,null,null,null);s.default=n.exports}}]);