# 全局解释器锁 (GIL)

## 1. GIL
GIL(Global Interpreter Lock)是CPython中一个防止解释器多线程并发执行机器码的一个全局互斥锁。其存在主要是因为在代码执行过程中，CPython的内存管理不是线程安全的。

GIL是最初为了适应多核CPU而引入多线程开发时的一种解决多线程之间数据完整性和状态同步的机制全局互斥锁。

GIL机制慢慢暴露出低效率的问题，但完全摒弃异常困难。GIL其实是功能和性能之间权衡后的产物。GIL在不断被改造，但在较长一段时间内仍将会继续存在。

## 2. 伪多线程
GIL作为全局锁的存在会对多线程的效率有很大的影响，导致CPython下的伪多线程，甚至就几乎等于是个单线程。

CPython中线程就是C语言的一个pthread，并通过操作系统调度算法进行调度（例如linux是CFS）。为了让各个线程能够平均利用CPU时间，python会计算当前已执行的微代码数量，达到一定阈值后就强制释放GIL。而这时也会触发一次操作系统的线程调度（当然是否真正进行上下文切换由操作系统自主决定）。

```py
# GIL原理伪代码

while True:
    acquire GIL
    for i in 1000:
        do something
    release GIL
    # Give Operating System a chance to do thread scheduling
```
这种模式单核CPU下没有问题，多核CPU情况就不一样了。从release GIL到acquire GIL之间几乎是没有间隙的，当其它核心上的线程被唤醒时，大部分情况下主线程已经再一次获取到GIL，此时被唤醒的线程无法抢到GIL只是白白浪费CPU时间，到切换时间时进入待调度状态，再被唤醒，再等待，以此往复恶性循环，当然实际的GIL并非如此简单，它也在版本升级中不断的被优化。

GIL的存在一定程度上对操作系统线程调度资源造成了浪费，导致多线程无法很好的利用多核CPU的并发处理能力。只有对IO密集型操作，GIL才能起到一定积极作用。

## 3. 避免GIL影响
了解了GIL存在的问题，我们可以从如下几个方面入手避免其负面影响。

### 1) 使用多进程
[多进程](process.md)的出现很大程度上是为了弥补因为GIL导致的[多线程](thread.md)低效的缺陷。每个进程有独立的GIL，因此也不会出现进程间的GIL争抢。当然多进程也带来进程间通讯的问题。

### 2) C语言混合开发
对并行计算性能较高的程序可以考虑核心部分使用C语言开发，然后使用C模块引入python实现混合开发。

### 3) 其他解释器
我们直到GIL是CPython的产物，JPython和IronPython开发语言自身实现了真正的多线程，也不需要GIL的帮助。使用这些解释器也会带来无法利用社区众多C语言模块的问题。

> 参阅文档 https://blog.csdn.net/qq_34802511/article/details/81227200